package org.example.Classes.Encryption;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.ExternalSigningSupport;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.cms.ContentInfo;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cms.*;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.util.Store;


import java.io.*;
import java.security.*;
import java.security.cert.CertSelector;
import java.security.cert.CertStore;
import java.security.cert.X509Certificate;
import java.util.Calendar;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class SignatureManager {
    static {

        Security.addProvider(new BouncyCastleProvider());
    }

    public void SignPDF(File filePDF, PrivateKey privateRSA) throws Exception {
        String fileName = filePDF.getName();
        String outName = filePDF.getAbsolutePath().substring(0, filePDF.getAbsolutePath().lastIndexOf(".")) + "_signed.pdf";
        try (PDDocument document = PDDocument.load(filePDF); OutputStream out = new FileOutputStream(outName)) {
            PDSignature signature = new PDSignature();
            signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);
            signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);
            signature.setName("Private Key Holder");
            signature.setLocation("Gdansk University of Technology, Gdsnsk");
            signature.setReason("Project needs");

            // the signing date, needed for valid signature
            signature.setSignDate(Calendar.getInstance());

            document.addSignature(signature);
            ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(out);

            byte[] signedDocBytes = SignWithPKCS7(externalSigning.getContent().readAllBytes(), privateRSA);

            externalSigning.setSignature(signedDocBytes);

            // Save the signed PDF document
            document.save(outName);
            //document.close();
            System.out.println("Signed!");
        }
    }

    public byte[] SignWithPKCS7(byte[] content, PrivateKey privateRSA) throws Exception {
        /*Signature rsaSignature = Signature.getInstance("SHA256withRSA");
        rsaSignature.initSign(privateRSA);

        // Update the signature with the document content to be signed
        rsaSignature.update(content);

        // Return the PKCS#7 (CMS) signature bytes
        return rsaSignature.sign();*/
        /*CMSSignedData signedData;
        ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256withRSA").build(privateRSA);
        CMSProcessableByteArray cmsProcessableByteArray = new CMSProcessableByteArray(content);

        signedData = new CMSSignedData(cmsProcessableByteArray);

        // Get the signature bytes in PKCS#7 format (CMS)
        byte[] pkcs7Signature = signedData.getEncoded();

        return pkcs7Signature;*/
        // Initialize BouncyCastle

        ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256withRSA").build(privateRSA);

        // Wrap the content to be signed in CMSProcessable
        CMSProcessableByteArray processable = new CMSProcessableByteArray(content);

        // Set up the CMS Signed Data Generator
        CMSSignedDataGenerator signedDataGenerator = new CMSSignedDataGenerator();

        // Use the JcaSignerInfoGeneratorBuilder to build a SignerInfoGenerator
        JcaSignerInfoGeneratorBuilder signerInfoGeneratorBuilder = new JcaSignerInfoGeneratorBuilder();
        signerInfoGeneratorBuilder.setDirectSignature(true);  // No certificate

        // Add the signer (private key signer) to the generator
        signedDataGenerator.addSignerInfoGenerator(signerInfoGeneratorBuilder.build(contentSigner));

        // Generate the CMS (PKCS#7) signed data
        CMSSignedData signedData = signedDataGenerator.generate(processable, false);

        // Return the PKCS#7 signed bytes (this is the signature)
        return signedData.getEncoded();
    }

    public boolean VerifyPDF(File filePDF, PublicKey publicRSA) throws Exception {
        PDDocument document = PDDocument.load(filePDF);

        // Get the signature from the document
        List<PDSignature> signatureList = document.getSignatureDictionaries();

        //PDSignature signature = signatureList.getFirst();

        // Get raw signature content (this is the byte array we're dealing with)
        for (int i = 0; i < signatureList.size(); i++) {
            PDSignature signature = signatureList.get(i);
            System.out.println("Signature " + (i + 1) + ": ");
            System.out.println("Name: " + signature.getName());
            System.out.println("Location: " + signature.getLocation());
            System.out.println("Reason: " + signature.getReason());

            // Extract raw signature content (byte array)
            byte[] signatureContent = signature.getContents();

            // Debug: Print out the raw signature content in hexadecimal form
            System.out.println("Raw signature content (hex): ");
            for (byte b : signatureContent) {
                System.out.format("%02x ", b);
            }
            System.out.println();
        }

        document.close();

        return true;

        // Step 1: Get the signed content (the hash of the document) from the signature
        /*byte[] signedContent = getSignedContentFromSignature(signature);

        // Step 2: Generate the hash of the original document (excluding the signature field)
        byte[] documentHash = generateDocumentHash(document);

        // Step 3: Compare the two hashes to verify the document
        return compareHashes(signedContent, documentHash);*/

    }

    private static byte[] getSignedContentFromSignature(PDSignature signature) throws Exception {
        // Extract the contents of the signature (PKCS#7 structure)
        byte[] signatureContent = signature.getContents();
        System.out.println(signature);

        // Use BouncyCastle to parse the PKCS#7 structure
        CMSSignedData signedData = new CMSSignedData(new ByteArrayInputStream(signatureContent));

        // Extract the signed content (this should be the document hash)
        Store<?> store = (Store<?>) signedData.getSignedContent();
        ASN1Object signedContent = (ASN1Object) store.getMatches(null).iterator().next();

        // Return the signed content (hash of the document)
        return signedContent.getEncoded();
    }

    private static byte[] generateDocumentHash(PDDocument document) throws Exception {
        byte[] documentBytes = extractDocumentBytesWithoutSignature(document);
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        return digest.digest(documentBytes);
    }

    // Compares the signed hash with the generated document hash
    private static boolean compareHashes(byte[] signedHash, byte[] documentHash) {
        return MessageDigest.isEqual(signedHash, documentHash);
    }

    // Extracts the document content excluding the signature field
    private static byte[] extractDocumentBytesWithoutSignature(PDDocument document) throws Exception {
        // Remove the signature field before generating the hash
        // (A more complex approach can be used to specifically remove signature fields)
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        document.save(byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }
}
